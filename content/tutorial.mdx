---
title: "Tutorial"
description: "Tutorial for C Traceback"
author: "Ching-Yin Ng"
date: "2025-12-31"
---

# Tutorial

<Callout>This tutorial is not finished yet</Callout>

## Project Setup

For demonstration, let us start with a simple vector calculation project.
Below is the sample code written with C99. It does four things:

1. Allocate memory for vector.
2. Initialize values for vector.
3. Divide every vector element by denominator.
4. Clean up.

Let us look at them one by one.
```c
/**
 * \file: project.c
 */

#include <stdio.h>
#include <stdlib.h>

#include "c_traceback.h"

int main(void)
{
    const size_t n = 1000;     // Vector size
    const double denominator = 123.0;

    /* Allocate memory */

    /* Initialize values */

    /* Division */

    /* Clean up */

    return 0;

error_clean_up:
    /* Error clean up */

    return 1;
}
```

## Allocate memory
For demonstrative purpose, let us try allocating memory by using a function.
Below is what I would write in C99:
```c
int alloc_memory(double **arr, const size_t n)
{
    *arr = malloc(n * sizeof(double));
    if (!(*arr))
    {
        return 1;   // Failed to allocate memory
    }
    return 0;
}
```
While the function is fine for a simple project, it is better to have an error traceback
and error message so that users know what happened without having to go through
your source code.

### `RAISE_ERROR` <Badge text="Macro" />
We can first make use of the `RAISE_ERROR` macro.
Instead of returning a value, we raise an error instead.
```c /void/ {6-7}
void alloc_memory(double **arr, const size_t n)
{
    *arr = malloc(n * sizeof(double));
    if (!(*arr))
    {
        // Failed to allocate memory
        RAISE_ERROR(CTB_MEMORY_ERROR, "Failed to allocate memory for vector!");
    }
}
```
However, it doesn't do much by itself. It only silently records an error.
We will have to modify some code in the `main` function.

### `TRACE` <Badge text="Macro" />
On the outer scope, we can wrap our function call with `TRACE`, which
returns an boolean error value. On top of that, `TRACE` will manage
the call stack automatically for you.
```c /TRACE/
/* Allocate memory */
double *arr;
if (!TRACE(alloc_memory(&arr, n)))
{
    goto error_clean_up;
}
```

### `TRY_GOTO` <Badge text="Macro" />
`TRY_GOTO` does the same thing as `TRACE`, but it jumps to a label when
the expression fails.
```c /TRY_GOTO
/* Allocate memory */
double *arr;
TRY_GOTO(alloc_memory(&arr, n), error_clean_up);
```

## Clean up
### `ctb_dump_traceback` <Badge text="Function" />
Now, add `ctb_dump_traceback` at the error handling. It will log the traceback to `stderr`
and reset the internal error status.
```c
int main(void)
{
    /* Clean up */
    free(arr);
    return 0;

error_clean_up:
    /* Error clean up */
    free(arr);
    ctb_dump_traceback();
    return 1;
}
```
Below is the final code. Lets set `n` to 1000000000000000 to see what happens.
```c {10, 14, 19, 26, 31-32, 36-44}
/**
 * \file: project.c
 */
 
#include <stdio.h>
#include <stdlib.h>
 
#include "c_traceback.h"

void alloc_memory(double **arr, const size_t n);
 
int main(void)
{
    const size_t n = 1000000000000000;     // Vector size
    const double denominator = 123.0;
 
    /* Allocate memory */
    double *arr;
    TRY_GOTO(alloc_memory(&arr, n), error_clean_up);
 
    /* Initialize values */
 
    /* Division */
 
    /* Clean up */
    free(arr);
    return 0;
 
error_clean_up:
    /* Error clean up */
    free(arr);
    ctb_dump_traceback();
    return 1;
}
 
void alloc_memory(double **arr, const size_t n)
{
    *arr = malloc(n * sizeof(double));
    if (!(*arr))
    {
        // Failed to allocate memory
        RAISE_ERROR(CTB_MEMORY_ERROR, "Failed to allocate memory for vector!");
    }
}

```
#### Output
`n` is too big to be allocated on any single computer.
You should see the traceback below.
<Callout type="info">If you don't see the traceback, turn off optimization flags by using `-O0` as compilers could optimize the malloc away.</Callout>
```ansi
[0;31m--------------------------------------------------[0m
[1;31mTraceback[0m [0;31m(most recent call last):[0m
  [38;5;240m(#00)[0m [38;5;240mFile "[0m[38;5;240m/Users/alvinng/Desktop/project/[0m[1;36mproject.c[0m[38;5;240m", line[0m [1;36m19[0m [38;5;240min[0m [1;36mmain[0m:
    [0;31malloc_memory(&arr, n)[0m
  [38;5;240m(#01)[0m [38;5;240mFile "[0m[38;5;240m/Users/alvinng/Desktop/project/[0m[1;36mproject.c[0m[38;5;240m", line[0m [1;36m42[0m [38;5;240min[0m [1;36malloc_memory[0m:
    [0;31m<Error raised here>[0m
[1;31mMemoryError:[0m [0;31mFailed to allocate memory for vector![0m
[0;31m--------------------------------------------------[0m
```




```c
/**
 * \file: project.c
 */

#include <stdio.h>
#include <stdlib.h>

int alloc_memory(double **arr);
void division(double *arr, double denominator, const int n);

int main(void)
{
    const int n = 1000;     // Vector size
    const double denominator = 123.0;

    /* Allocate memory */
    double *arr;
    if (!alloc_memory(&arr, n))
    {
        goto error;
    }

    /* Initialize values */
    for (int i = 0; i < n; i++)
    {
        arr[i] = i;
    }

    /* Do calculation */
    division(arr, denominator, n);
    
    /* Clean up */
    free(arr);
    return 0;

error:
    /* Error clean up */
    free(arr);
    return 1;
}

int alloc_memory(double **arr, const int n)
{
    *arr = malloc(N * sizeof(double));
    if (!(*arr))
    {
        return 1;   // Failed to allocate memory
    }
    return 0;
}

void division(double *arr, double denominator, const int n)
{
    for (int i = 0; i < n; i++)
    {
        arr[i] /= denominator;
    }
}
```